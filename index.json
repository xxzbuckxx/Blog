[{"content":"Concept This game was one of my first coding projects, and I originally made it using a single file of javascript and some boilerplate HTML.\nThe game has evolved a lot since then, using typescript for the core game and React for the UI components.\nA web game I designed with a global leaderboard, an upgrade shop, and account functionality to save progress. The top down arcade was fully designed and implemented by me.\n","permalink":"https://xxzbuckxx.github.io/Blog/posts/game-blob-mob/","summary":"Concept This game was one of my first coding projects, and I originally made it using a single file of javascript and some boilerplate HTML.\nThe game has evolved a lot since then, using typescript for the core game and React for the UI components.\nA web game I designed with a global leaderboard, an upgrade shop, and account functionality to save progress. The top down arcade was fully designed and implemented by me.","title":"Game - Blob Mob"},{"content":"Concept During my 2022 internship with Under.io I was tasked with making an interactive dashboard.\nAt a startup, it is crucial to understand where the business is at. That is why I was tasked with building an admin dashboard that displayed important site metrics and allowed easy access of customer data.\n","permalink":"https://xxzbuckxx.github.io/Blog/posts/under-metric-system/","summary":"Concept During my 2022 internship with Under.io I was tasked with making an interactive dashboard.\nAt a startup, it is crucial to understand where the business is at. That is why I was tasked with building an admin dashboard that displayed important site metrics and allowed easy access of customer data.","title":"Under Metric System"},{"content":"tags: ThreeJS JavaScript NodeJS title: \u0026ldquo;3D visualization - Points on Sphere\u0026rdquo;\nConcept This is a visualization for an algorithm that distributes points evenly on a sphere. My first attempts were at implementing the algorithm myself using this stackoverflow post. However, I did not quite get the visualization I wanted, so I used Sebastion Lague\u0026rsquo;s implementation instead.\n See Visualization Here See Code Here  References  Stackoverflow post Sebastion Lague\u0026rsquo;s implementation  ","permalink":"https://xxzbuckxx.github.io/Blog/posts/3d-visualization-points-on-sphere/","summary":"tags: ThreeJS JavaScript NodeJS title: \u0026ldquo;3D visualization - Points on Sphere\u0026rdquo;\nConcept This is a visualization for an algorithm that distributes points evenly on a sphere. My first attempts were at implementing the algorithm myself using this stackoverflow post. However, I did not quite get the visualization I wanted, so I used Sebastion Lague\u0026rsquo;s implementation instead.\n See Visualization Here See Code Here  References  Stackoverflow post Sebastion Lague\u0026rsquo;s implementation  ","title":"3D Visualization - Points On Sphere"},{"content":"type: #work #project tags: JavaScript DSI 3d modeling complexity theory\nNote: This was one of my DSI Long-Term Project Ideas title: \u0026ldquo;3D visualization - Boids\u0026rdquo;\nConcept Using the 3D visualization tools in the DSI I plan to make an interactive visualization. Specifically I plan to replicate flocking behavior using Boids, an emerging phenomena and example of complexity theory.\nI hope to use the Looking Glass Portrait, and the Looking Glass 4K to display my simulation in holographic 3D space. Additionally, I plan to use Ultraleap to interact with the by tracking a hand in open air.\nHere is my non-holographic demo.\nEquipment  Looking Glass   Project Log I documented my progress on this project below. Although this is not meant to be a guide, it can be used as one given some experience in JavaScript and the code provided at the beginning of each update.\n 22-02-23 Software Compatibility \u0026amp; ThreeJS Setup Here is the code at the end of this stage\nFirst Thing I looked into is the software that allows the looking glass/portrait to visualize things real time. Luckily, HoloPlay (the software that the portrait uses) has a plugin for ThreeJS, a javascript framework I have a bit of experience in.\nHoloPlayer ThreeJS Plugin Tutorial\nFortunately, I had already made a 2D vision of a Boid simulation using JavaScript inspired by Flocks, Herds, and Schools: A Distributed Behavioral Model. It would take some work as I needed to change rendering engines for HTML5\u0026rsquo;s Canvas to ThreeJS, but the logic of the simulation was already figured out which would greatly reduce the difficulty in making the simulation.\nAfter restructuring the project and adding a import-map to use JavaScript Modules, I made a simple rotating cube animation.\n 22-02-25 Debug Setup and Naive Boid Movement Here is the code at the end of this stage\nNow that the camera and renderer were setup, I began working on animating a single Boid. I used my constructed box as a bounding box to contain the Boids (eventually this bounding box will be the Looking Glass). I used my previous 2D Boid Code as a template for the methods and operations I needed, and I kept the same Boid/BoidController structure with my BoidController class needing minor adjustments.\nInitializing a Boid The first thing I did was create a Boid mesh. The geometry of a Boid can be anything; in more practical examples the mesh would be a bird, or a fish. However to simplify debugging I made the mesh a Tetrahedron with the built-in normal material:\nconst geometry = new THREE.ConeGeometry(0.05, 0.2, 3); const material = new THREE.MeshNormalMaterial(); Along with the shape, the main Differences in Boid proprieties were representing the position and velocity as a THREE.vector3 instead of as individual vector components.\nSince I was now using vectors, most of my code could be easily simplified as ThreeJS has all of the needed vector operations built into their THREE.Vector3 class. This left the refactored code looking much cleaner but also took some time and research into using ThreeJS properly.\nHere is how the Boid is initialized now:\nconstructor(x, y, z) { // Create Mesh  this.mesh = new THREE.Mesh(geometry, material); this.mesh.position.set(x, y, z); // Randomize velocity  this.vel = new THREE.Vector3().randomDirection(); this.maxSpeed = 0.02 } Moving a Boid Now that Boids can be created, I need them to move and do things. First I made a simple function to randomly place the Boid somewhere in the bounding box. Next I focused on the basic operations in the update loop: moving a Boid according to its velocity, and pointing a Boid in the direction of its velocity.\nThese operations only required basic vector operations already implemented in ThreeJS:\n// Update positions this.mesh.position.add(this.vel); // Update direction const axis = new THREE.Vector3(0, 1, 0); this.mesh.quaternion.setFromUnitVectors(axis, this.vel.clone().normalize()); Now that a Boid can move, it needs to stay below a maximum speed, and stay within a bounding box. To handle speed I again used simple ThreeJS methods to clamp the speed of a Boid. Then to keep inside the bounding Box, I implemented a function pushOnScreen(boundary) that checks if the position of a Boid exceeds the box boundary subtracted by a margin. I adjust each component of the velocity vector by a turning factor to steer away from the wall and back towards the center.\nconst boundingBox = new THREE.Box3().setFromObject(boundary); const origin = boundingBox.min; const size = new THREE.Vector3(); boundingBox.getSize(size); // x component if (this.mesh.position.x \u0026lt; origin.x + this.margin) this.vel.x += this.turnFactor; else if (this.mesh.position.x \u0026gt; origin.x + size.x - this.margin) this.vel.x -= this.turnFactor; // y \u0026amp; z components are the same After making some debug methods and camera controls, I can now spawn a Boid that moves within a box:\nSpawning multiple Boids makes the animation already has some ~pizzaz~:\nFinally, I implemented the other rules of Boids using the same component approach as the 2D implementation. This is bad because computing vector components this way uses the CPU with each calculation being one at a time. I think A better implementation would take advantage of ThreeJS vector operations. The code would be cleaner as vector operations would be one line and done as ThreeJS intended. However, for even faster computations I may need to implement JavaScript workers or run vector computations on the GPU.\nRegardless, here are some working swarms with different meshes and other small tweaks:\n 22-02-25 Optimization Here is the code at the end of this stage\nAs I have stated before, there are a few ways to optimize the simulation so I can render more Boids with less work from the computer. There are 2 main things I can do:\n Optimize vertex computations - Perform all vertex operations in one loop, instead of three functions Optimize draw calls - Since all the Boids are the same mesh, ThreeJS has a special mesh instance that can draw all of them in one call  First I rewrote the Boid methods to use ThreeJS vector operations instead of \u0026ldquo;manual\u0026rdquo; component computations. After the three methods were reimplemented, I combined them into one single method, sim(boids), that enacted all three forces in a single loop. This improved performance as the algorithm was running through every Boid three times per Boid before, and now is only running through every Boid once per Boid.\nlet neighbors = 0; let match = new THREE.Vector3(); let center = new THREE.Vector3(); for (let otherBoid of boids) { if (this.distance(otherBoid) \u0026gt;= this.field) continue; neighbors++; // Avoid Others (separation)  if (otherBoid !== this \u0026amp;\u0026amp; this.distance(otherBoid) \u0026lt; this.minSeperation) { let avoid = this.vel.clone().sub(otherBoid.vel) this.vel.addScaledVector(avoid, this.avoidFactor); // apply avoid force  } // Match (alignment)  match.add(otherBoid.vel) // Center (cohesion)  center.add(otherBoid.mesh.position); } // Apply Match Force match.add(this.vel); match.divideScalar(neighbors); this.vel.addScaledVector(match, this.matchFactor); // Apply Center Force center.divideScalar(neighbors); center.sub(this.mesh.position); this.vel.addScaledVector(center, this.centeringFactor); Second, I tried optimizing the mesh drawing, into a single GPU draw call. Since all the meshes are the same, I wanted to use THREE.InstancedMesh in ThreeJS. I got multiple meshes to render successfully, but I could not figure out a position transformation on a single mesh. After a lot of struggling I gave up, as the draw calls do not seem to be much of a bottle neck, and it was not worth the pain to try and figure it out. I will probably revisit this when I start importing more complicated meshes but for now I am leaving it alone.\nNow the total amount my computer could render before lagging and heating up went from 300 Boids to 800 Boids.\n 22-02-25 Ocean Feel and Code Cleanup Here is the Code at the end of this stage\nNow that I can simulate flocking and my computer does not light on fire, I want to apply this simulation in a scenario. So why not simulate fish?\nFirst I added some debugging tools using dat.gui. This way I could adjust the parameters of a flock easily and see the changes real time.\nNow I focused on the scene. I added a yellow plane at the bottom of the bounding box and changed the color of the fog to blue. Then I expanded the bounding box and camera depth to make the scene feel more like an ocean.\nNext I wanted to be able to simulate different kinds of fish, possibly with different attributes and colors. To do this I just made another Boid controller. This way Boids would only be affected by the other Boids in their flock, meaning different types of fish will not try to swim together. One problem with this solution is that flocks will not try to avoid other flocks, the meshes will past straight through each other. However, this is not a big concern for me right now so maybe I\u0026rsquo;ll come back to it later.\nHere is how the simulation looks now:\nWith all these changes to the scene, the initialization function (Init()) became really dense and hard to read. It was about time to make a World class that would store the various world elements and their initialization.\nThe following objects are contained in the World instance called ocean:\n Scene Camera Light Fog Bounding Box Renderer Camera Controls  Each of these objects has its own initialization method, to make the main World constructor easier to understand as well.\nIn addition to separating some of the initialization from main.js, I also gave the BoidController class its own file, instead of keeping it at the bottom of boid.js.\n 22-03-07 Importing Models The next step in making my simulation look more like the ocean is actually importing the fish models. Luckily, ThreeJS has a module to import 3D models from a variety of 3D formats. The format I will be using is glTF 2.0 (here is why) so I downloaded the and setup the ThreeJS glTF Loader Module.\nAll I needed to do was load the model in, then clone the Model for each Boid instance to store. This should have been a simple step but I had a bit of difficulty because I did not read enough into the documentation. In the ThreeJS loader I was using it loaded things asynchronously, meaning JavaScript would create a task to load the model, but continue to animate and execute code why the model loaded in the background.\nconst loader = new GLTFLoader(); const fishData = await loader.loadAsync(\u0026#39;../models/logo.glb\u0026#39;); const fishMesh = fishData.scene.children[0]; return { fishMesh } This is obviously helpful most cases where you want to reduce loading lag. Usually you do not want your whole program to halt completely while it loads in a bunch of data. However, to initialize and animate a Boid, the model needed to be initialized first. The mesh holds the position data so the position cannot be changed until the mesh exists. To solve this issue I used the await keyword to insure the import finishes before the rest of the initialization code is executed.\nFor the test fish 3D Model I used blender to convert a STL file into a glTF. I used the UCSC letters model from my 3D Print - UCSC Word project. After scaling and adjusting some world values, the result looks like so:\n 22-04-22 Code Refactor and GUI Update Here is the code at the end of this stage\nAs the simulation is nearly finished, it was time to figure out the logistics of interfacing Holoplay (the holographic display software) with my simulation. I knew that ThreeJS would work with the software but I had to think about the easiest way to do this. At the same time, I looked over my Javascript modules and I didn\u0026rsquo;t like my long import map in my index. Although I loved the simplicity of vanilla Javascript, it was about time to put some more infrastructure behind my code.\nI decided to refactor my code and use Typescript with NodeJS. Dealing with all the different types of meshes and geometries and various objects being passed through functions it would definitely help to have a strongly typed language to stop me from making silly mistakes. I decided to use Vite to bundle my Typescript into a static site. I have heard a lot of good things about Vite and I wouldn\u0026rsquo;t a simple web bundler that did not require much configuration. Not that I was using Node I imported ThreeJS and its extensions through Npm instead of using downloaded releases.\nAfter all the refactoring, I decided to redo the GUI that controlled the Boid Parameters. I did not like how it was so cluttered, and I wanted the separation, alignment, and cohesion to be clearly distinct with one value each. Here is the old GUI:\nFirst I got rid of the avoidFactor attribute and instead made it equal to 2*this.attributes.maxSpeed/100*this.attributes.minSeperation. This way the avoid factor would scale with the speed and separation distance instead of being a manually controlled parameter. This allowed me to get rid of the subfolders in the GUI making the overall interface a lot cleaner.\nNext, I decided to scale my Boid attributes to have more sensible parameters. The decimal representations were not very pretty and it was confusing that the centeringFactor was 100x smaller than everything else. I spent some time making good coefficients to this attributes, so that the scales would all be from 1 to 10, except for the maxSpeedY which was a ratio of the total speed from 0 to 1. With all of this implemented I renamed the attributes to their original terms and the updated GUI looked a lot cleaner and was a lot more satisfying to control:\nFinally, I decided to do some Git cleanup and add this log to the Github. I wanted the repo to contain all the information about the project so I uploaded the images and this README. Then I merged the 3D branch into the main, and created a gh-pages branch to designate for the static site to be displayed.\n 22-05-24 Vicky\u0026rsquo;s Fish Here is the code at the end of this stage\nFinally I have fish! Thanks to Vicky from the DSC, I finally have 3D fish models to represent my boids. Here they are imported into the simulation:\nOne thing I need to address is the material on the fish. Flat shading like this makes them sort of resemble blobs and takes away from the excellent modeling work that was done. Either I need to add texture, or change the material and lighting for the scene.\n References  boid simulation Boid Github Repository Leap Motion WebGL Demo Leap Motion Tutorial Something to Aspire to?  ","permalink":"https://xxzbuckxx.github.io/Blog/posts/3d-visualization-boids/","summary":"type: #work #project tags: JavaScript DSI 3d modeling complexity theory\nNote: This was one of my DSI Long-Term Project Ideas title: \u0026ldquo;3D visualization - Boids\u0026rdquo;\nConcept Using the 3D visualization tools in the DSI I plan to make an interactive visualization. Specifically I plan to replicate flocking behavior using Boids, an emerging phenomena and example of complexity theory.\nI hope to use the Looking Glass Portrait, and the Looking Glass 4K to display my simulation in holographic 3D space.","title":"3D Visualization - Boids"},{"content":"Concept A 2d-platformer shooter set on an extraterrestrial planet. Besides some help with a few visual assets, programming, design, and music was done by me.\n","permalink":"https://xxzbuckxx.github.io/Blog/posts/game-ralphs-space-quest/","summary":"Concept A 2d-platformer shooter set on an extraterrestrial planet. Besides some help with a few visual assets, programming, design, and music was done by me.","title":"Game - Ralph's Space Quest"}]